<?php

/**
 * Quick and dirty file fetcher, to be able to fetch files generated by the Horaro Text File plugin over networks.
 */

$opts = "c:";
$longopts = [
    "config:"
];

$options = getopt($opts, $longopts);
$configFile = $options['c'] ?? $options['config'] ?? null;

if (empty($configFile)) {
    die("Missing config.\n");
}

$config = json_decode(file_get_contents($configFile), true);

if(empty($config)) {
    die("Invalid config.\n");
}

$previousContents = null;
$scheduledUpdates = [];
$earliestUpdate = null;

foreach($config['output'] as &$outputConfig) {
    $outputConfig['id'] = uniqid("", true);
    $outputConfig['delayOriginal'] = $outputConfig['delay'] ?? null;
    $outputConfig['delay'] = new DateInterval($outputConfig['delay'] ?? "PT0S");
}

while (true) {
    $contents = file_get_contents($config['input']);
    $now = new DateTimeImmutable();

    // File update: prepare updating the actual files according to the given delays
    if($contents != $previousContents) {
        echo "Updating target files...\n";
        $previousContents = $contents;
        
        $contents = explode($config['split'], $contents);

        // Split items that need in-line splitting
        if(!empty($config['itemSplit']) && is_array($config['itemSplit'])) {
            foreach($config['itemSplit'] as $index => $splitString) {
                if(isset($contents[$index])) {
                    $contents[$index] = explode($splitString, $contents[$index]);
                }
            }
        }

        foreach($config['output'] as $output) {
            $outputContents = $output['content'];

            $varCount = preg_match_all("/\\$([0-9]+)(?:\\.([0-9]+))?/", $outputContents, $matches);

            if(!empty($varCount)) {
                $replaces = 0;
                arsort($matches[0]);

                foreach($matches[0] as $i => $match) {
                    $firstIndex = $matches[1][$i];
                    $secondIndex = $matches[2][$i] ?? null;

                    if(isset($contents[$firstIndex])) {
                        $replaceValue = $contents[$firstIndex];

                        if(strlen($secondIndex) > 0 && isset($replaceValue[$secondIndex])) {
                            $replaceValue = $replaceValue[$secondIndex];
                        } elseif(strlen($secondIndex) > 0 && !isset($replaceValue[$secondIndex])) {
                            continue;
                        }
                        
                        $outputContents = str_replace($match, $replaceValue, $outputContents);
                        $replaces++;
                    }
                }
            }
            
            // Set the contents as empty if a var couldn't be fullfilled
            if($replaces != count($matches[0])) {
                $outputContents = "";
            }

            $scheduledUpdates[] = [
                'file' => $output['file'],
                'time' => $now->add($output['delay']),
                'content' => $outputContents
            ];
        }
    }

    // Handle actual file updates based off scheduled updates
    $keptScheduledUpdates = $scheduledUpdates;
    foreach($scheduledUpdates as $i => $scheduledUpdate) {
        if($now >= $scheduledUpdate['time'] || !file_exists($scheduledUpdate['file'])) {
            $originalContent = null;
            if(file_exists($scheduledUpdate['file'])) {
                $originalContent = file_get_contents($scheduledUpdate['file']);
            }

            if($originalContent !== $scheduledUpdate['content']) {
                file_put_contents($scheduledUpdate['file'], $scheduledUpdate['content']);
                echo "Updating ". $scheduledUpdate['file']. (empty($scheduledUpdate['content']) ? " (empty)" : "") . "...\n";
            }

            unset($keptScheduledUpdates[$i]);
        }
    }

    $scheduledUpdates = $keptScheduledUpdates;
    
    sleep($config['time']);
}
