<?php

/**
 * Quick and dirty file fetcher, to be able to fetch files generated by the Horaro Text File plugin over networks.
 */

$opts = "c:";
$longopts = [
    "config:"
];

$options = getopt($opts, $longopts);
$configFile = $options['c'] ?? $options['config'] ?? null;

if (empty($configFile)) {
    die("Missing config.\n");
}

$config = json_decode(file_get_contents($configFile), true);

if(empty($config)) {
    die("Invalid config.\n");
}

$previousContents = null;
$scheduledUpdates = [];
$earliestUpdate = null;

foreach($config['output'] as &$outputConfig) {
    $outputConfig['id'] = uniqid("", true);
    $outputConfig['delayOriginal'] = $outputConfig['delay'] ?? null;
    $outputConfig['delay'] = new DateInterval($outputConfig['delay'] ?? "PT0S");
}

while (true) {
    $contents = file_get_contents($config['input']);
    $now = new DateTimeImmutable();

    // File update: prepare updating the actual files according to the given delays
    if($contents != $previousContents) {
        echo "Updating target files...\n";
        $previousContents = $contents;
        
        $contents = explode($config['split'], $contents);

        foreach($config['output'] as $output) {
            $outputContents = $output['content'];

            $varCount = preg_match_all("/\\$([0-9]+)/", $outputContents, $matches);

            if(!empty($varCount)) {
                $replaces = 0;

                foreach($matches[1] as $match) {
                    if(isset($contents[$match])) {
                        $outputContents = str_replace("$". $match, $contents[$match], $outputContents);
                        $replaces++;
                    }
                }
            }
            
            // Set the contents as empty if a var couldn't be fullfilled
            if($replaces != count($matches[0])) {
                $outputContents = "";
            }

            $scheduledUpdates[] = [
                'file' => $output['file'],
                'time' => $now->add($output['delay']),
                'content' => $outputContents
            ];
        }
    }

    // Handle actual file updates based off scheduled updates
    $keptScheduledUpdates = $scheduledUpdates;
    foreach($scheduledUpdates as $i => $scheduledUpdate) {
        if($now >= $scheduledUpdate['time'] || !file_exists($scheduledUpdate['file'])) {
            $originalContent = null;
            if(file_exists($scheduledUpdate['file'])) {
                $originalContent = file_get_contents($scheduledUpdate['file']);
            }

            if($originalContent !== $scheduledUpdate['content']) {
                file_put_contents($scheduledUpdate['file'], $scheduledUpdate['content']);
                echo "Updating ". $scheduledUpdate['file']. (empty($scheduledUpdate['content']) ? " (empty)" : "") . "...\n";
            }

            unset($keptScheduledUpdates[$i]);
        }
    }

    $scheduledUpdates = $keptScheduledUpdates;
    
    sleep($config['time']);
}
